package de.uni_passau.fim.se2.sa.sign.interpretation;

import com.google.common.base.Preconditions;
import org.objectweb.asm.tree.analysis.Value;

import java.util.Set;

/** An enum representing the possible abstract values of the sign analysis. */
public enum SignValue implements Value {
  // Important! This implementation is kind of fragile. Don't change the order of enum values!
  // Otherwise, code will break ðŸ¤¡:)
  BOTTOM("âŠ¥", Set.of()), // 0
  MINUS("{â€“}", Set.of(Sign.MINUS)), // 1
  ZERO("{0}", Set.of(Sign.ZERO)), // 2
  ZERO_MINUS("{0,â€“}", Set.of(Sign.ZERO, Sign.MINUS)), // 3 == ZERO | MINUS
  PLUS("{+}", Set.of(Sign.PLUS)), // 4 == 4
  PLUS_MINUS("{+,â€“}", Set.of(Sign.PLUS, Sign.MINUS)), // 5 == PLUS | MINUS
  ZERO_PLUS("{0,+}", Set.of(Sign.ZERO, Sign.PLUS)), // 6 == ZERO | PLUS
  TOP("âŠ¤", Set.of(Sign.MINUS, Sign.ZERO, Sign.PLUS)), // 7 == MINUS | ZERO | PLUS
  UNINITIALIZED_VALUE("âˆ…", null); // 8

  private final String repr;
  private final Set<Sign> signs;

  SignValue(final String pRepr, Set<Sign> signs) {
    repr = pRepr;
    this.signs = signs;
  }

  public Set<Sign> getSigns() {
    return signs;
  }

  @Override
  public int getSize() {
    return 1;
  }

  @Override
  public String toString() {
    return repr;
  }

  // Below method is generated by LLM.
  // Please refer to LLM/code_queries.txt
  public SignValue join(final SignValue pOther) {
    Preconditions.checkState(
        this != UNINITIALIZED_VALUE && pOther != UNINITIALIZED_VALUE,
        "Dummy shall not be used as a value.");

    // BOTTOM joined with anything is the other value
    if (this == BOTTOM) return pOther;
    if (pOther == BOTTOM) return this;

    // TOP joined with anything is TOP
    if (this == TOP || pOther == TOP) return TOP;

    // Perform bitwise OR on ordinal values
    int joinedOrdinal = this.ordinal() | pOther.ordinal();
    return SignValue.values()[joinedOrdinal];
  }

  public boolean isLessOrEqual(final SignValue pOther) {
    Preconditions.checkState(
        this != UNINITIALIZED_VALUE && pOther != UNINITIALIZED_VALUE,
        "Dummy shall not be used as a value.");
    return this.join(pOther) == pOther;
  }

  public static boolean isZero(final SignValue pValue) {
    return pValue == ZERO;
  }

  public static boolean isMaybeZero(final SignValue pValue) {
    return pValue == ZERO || pValue == ZERO_MINUS || pValue == ZERO_PLUS || pValue == TOP;
  }

  public static boolean isNegative(final SignValue pValue) {
    return pValue == SignValue.MINUS;
  }

  public static boolean isMaybeNegative(final SignValue pValue) {
    return pValue == SignValue.MINUS || pValue == ZERO_MINUS || pValue == PLUS_MINUS || pValue == TOP;
  }

  public static SignValue fromSigns(Set<Sign> signs) {
    // Map the Set back to the correct SignValue
    for (SignValue val : values()) {
      if (val.signs.equals(signs)) {
        return val;
      }
    }
    return TOP;
  }
}
